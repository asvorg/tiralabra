# Specifications

- RSA implementation done in Rust.
- All the needed prime number generations will be implemented by me, as well as the relevant key generations.
- The primes will be generated by running a randomly generated number first through low level primality test and then checking with the Miller Rabin primality test if the number is prime.
- D calculated using the extended Euclidean algorithm
- Also actual text encryption will be possible
- The final program will only take text as an input and return the RSA encypted text, UTF-8
- Time complexity still unclear
- I am a TKT student
- The whole project will be done in english

## Key generation

The required primes, p and q are generated by the following method: first, a candidate is chosen at random. Then the candidate is ran through a list of small primes [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31], and the divisibility is checked. If the remainder is zero, the candidate is discarded and a new candidate is chosen. If the candidate passes it is then ran through the [Miller-Rabin primality test](https://en.wikipedia.org/wiki/Millerâ€“Rabin_primality_test), the number of iterations is 50, so if the candidate passes, the probability is very high that the candidate is a prime. This is done for both p and q. n is simply p $\times$ q. e is 65537 since it is a Fermat prime. Now $\phi$ is just $p - 1 \times q - 1$. Next the program checks if e and $\phi$ are coprime. Panic if they are not. Then d is calculated using the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm). Because calculating d with the EEA can result in d being negative, test if it is, and if it is negative, add $\phi$ to it, to make it positive. Now we have the public key (n,e) and private key(n,d).

## Encryption